# -*- coding: utf-8 -*-
"""Plant diseases Project FNN.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1hiCwknd_VWm71_A7fLCEFnRPoKFh4lLJ
"""

import os
import numpy as np
from PIL import Image
from sklearn.model_selection import train_test_split

base_path = "plant_disease"

contents = os.listdir(base_path)
if len(contents) == 1 and os.path.isdir(os.path.join(base_path, contents[0])):
    base_path = os.path.join(base_path, contents[0])

print("Using dataset folder:", base_path)

classes = [d for d in os.listdir(base_path) if os.path.isdir(os.path.join(base_path, d))]
print("Classes found:", classes)

IMG_SIZE = 64  # Resize images to 64x64

def load_images(base_path, classes, img_size=IMG_SIZE):
    X = []
    y = []
    for idx, cls in enumerate(classes):
        cls_folder = os.path.join(base_path, cls)
        if not os.path.exists(cls_folder):
            continue
        for img_file in os.listdir(cls_folder):
            img_path = os.path.join(cls_folder, img_file)
            try:
                img = Image.open(img_path).convert('RGB')
                img = img.resize((img_size, img_size))
                img_array = np.array(img)/255.0  # Normalize 0-1
                img_flat = img_array.flatten()    # Flatten for FNN
                X.append(img_flat)
                y.append(idx)
            except Exception as e:
                # Skip corrupted images
                print(f"Skipped {img_path} ({e})")
    return np.array(X), np.array(y)

X, y = load_images(base_path, classes)
print("Total images loaded:", len(X))
print("Shape of X:", X.shape)
print("Shape of y:", y.shape)

if len(X) > 0:
    X_train, X_test, y_train, y_test = train_test_split(
        X, y, test_size=0.2, random_state=42, stratify=y
    )
    print("Training samples:", X_train.shape[0])
    print("Testing samples:", X_test.shape[0])
else:
    print("No images loaded. Check dataset path and structure.")

plt.figure(figsize=(12, 8))
for i, cls in enumerate(classes[:6]):  # Show first 6 classes
    img_path = os.path.join(base_path, cls, os.listdir(os.path.join(base_path, cls))[0])
    img = Image.open(img_path)
    plt.subplot(2, 3, i+1)
    plt.imshow(img)
    plt.title(cls)
    plt.axis('off')
plt.show()

import tensorflow as tf
from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import Dense, Dropout
from tensorflow.keras.utils import to_categorical
from sklearn.metrics import roc_curve, auc, roc_auc_score, confusion_matrix, classification_report
import matplotlib.pyplot as plt
import seaborn as sns

num_classes = len(classes)
y_train_cat = to_categorical(y_train, num_classes)
y_test_cat = to_categorical(y_test, num_classes)

input_dim = X_train.shape[1]  # Flattened image size

model = Sequential([
    Dense(512, activation='relu', input_shape=(input_dim,)),
    Dropout(0.3),
    Dense(256, activation='relu'),
    Dropout(0.3),
    Dense(128, activation='relu'),
    Dense(num_classes, activation='softmax')
])

model.compile(
    optimizer='adam',loss='categorical_crossentropy',metrics=['accuracy'])

model.summary()

history = model.fit(X_train, y_train_cat,validation_data=(X_test, y_test_cat),epochs=20,batch_size=64)

"""#TEST Without downloaidng datset for quick work  
first download the "plant_diesease_fnn.keras" file and upload it colab vm if working on colab, use the the cell below to load the pre-trained model so that you dont have to download the 1.3GBs worth of dataset and wont need to train it again


"""

model = load_model("plant_disease_fnn.keras")

from tensorflow.keras.models import load_model
model = load_model("plant_disease_fnn.keras")

loss, acc = model.evaluate(X_test, y_test_cat)
print(f"Test Accuracy: {acc*100:.2f}%")

plt.plot(history.history['accuracy'], label='Train Accuracy')
plt.plot(history.history['val_accuracy'], label='Validation Accuracy')
plt.legend()
plt.show()

plt.plot(history.history['loss'], label='Train Loss')
plt.plot(history.history['val_loss'], label='Validation Loss')
plt.legend()
plt.show()

y_pred_prob = model.predict(X_test)

plt.figure(figsize=(10, 8))

for i in range(num_classes):
    fpr, tpr, _ = roc_curve(y_test_cat[:, i], y_pred_prob[:, i])
    roc_auc = auc(fpr, tpr)
    plt.plot(fpr, tpr, label=f"{classes[i]} (AUC = {roc_auc:.2f})")

plt.plot([0, 1], [0, 1], 'k--')  # Diagonal
plt.xlim([0.0, 1.0])
plt.ylim([0.0, 1.05])
plt.xlabel('False Positive Rate')
plt.ylabel('True Positive Rate')
plt.title('Multi-class ROC Curve')
plt.legend(loc='lower right')
plt.show()

micro_auc = roc_auc_score(y_test_cat, y_pred_prob, average='micro')
print("Micro-average AUC:", micro_auc)

y_pred_classes = np.argmax(model.predict(X_test), axis=1)
cm = confusion_matrix(y_test, y_pred_classes)

plt.figure(figsize=(10, 8))
sns.heatmap(cm, annot=True, fmt='d', cmap='Blues', xticklabels=classes, yticklabels=classes)
plt.xlabel('Predicted')
plt.ylabel('Actual')
plt.title('Normalized Confusion Matrix')
plt.show()

report = classification_report(y_test, y_pred_classes, target_names=classes, digits=2)
print("Classification Report:\n")
print(report)

model.save("plant_disease_fnn.keras")



